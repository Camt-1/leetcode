# 无重复字符的最长子串
> 给定一个字符串s,找出其中不含有重复字符的最长字串的长度

以字符串abcabcabc为例,找出从每一个字符开始的,不包含重复字符的最长字串,
那么其中最长的字符串即为答案,可以列举出以下结果:
- 以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb；
- 以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb；
- 以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb；
- 以 abc(a)bcbb 开始的最长字符串为 abc(abc)bb；
- 以 abca(b)cbb 开始的最长字符串为 abca(bc)bb；
- 以 abcab(c)bb 开始的最长字符串为 abcab(cb)b；
- 以 abcabc(b)b 开始的最长字符串为 abcabc(b)b；
- 以 abcabcb(b) 开始的最长字符串为 abcabcb(b)。

如果依次递增地枚举字串的起始位置,那么字串结束位置也是递增的!这里的原因在于,
假设选择字符串中的第k个字符作为起始位置,并且得到了不包含重复字符的最长字串的
结束位置rk.那么当选择第k+1个字符作为起始位置时,首先从k+1到rk的字符显然是不重复的,
并且少了原本的第k个字符,所以可以尝试继续增大rk,直到右侧出现了重复字符为止.


这样一来,就可以使用"滑动窗口"来解决这个问题
- 使用两个指针来表示字符串中的某个字串(或窗口)的左右边界,其中左指针代表着上文中
"枚举字串的起始位置",而右指针即为上文中的rk;
- 在每一步操作中,会将左指针向右移动一格,表示**开始枚举下一个字符作为起始位置**,然后
就可以不断地向右移动右指针,但需要保证这两个指针对应地字串中没有重复地字符.在移动结束后,
- 这个字串就对应着**以左指针开始的,不包含重复字符的最长字串**.记录下这个字串的长度;
在枚举结束后,找到最长的字串的长度即为答案

### 判断重复字符
在上面流程中,还需要使用一种数据结构来判断是否有重复的字符,常用的数据结构为哈希集合.
在左指针向右移动的时候,从哈希集合中移除一个字符,在右指针向右移动时,往哈希集合中添加一个字符.
